    Алгорит решения задачи III-E "Поле чудес" (Тензор)
    Выполнил: Холостов Михаил.
    Версия языка: Python 3.11

Основные операции выполняются в функции main:
    1. Чтение данных из файла "e.in.txt" и сохранение данных в список lst_numbers
    2. Нахождение результата
    3. Запись данных в файл "e.out.txt"

Рассмотрим п. 2 "Нахождение результата":

    1) С помощью функции get_dct_indexes на основании исходного списка чисел
    получим словарь dct_indexes, где ключами будут числа, встречающиеся на барабане,
    а значениями списки индексов этих чисел в исходном списке lst_numbers. Последнее число отбросим.

    2) Если длина словаря равна 1, значит последовательность состоит
    из повторения единственного числа. Тогда ответ - 1

    3) Если длина словаря не равна 1, то проведем следующие операции:

        3.1.) С помощью функции get_dct_diff получим словарь, где ключами будут числа,
        а значениями списки с разностями всех индексов этого числа,
        кроме первого, с индексом первого числа

        3.2.) С помощью функции make_intersection_set преобразуем все значения словаря
        dct_diff в множеста и найдем их пересечение - множество total_set

        3.3.) Добавим в множество в качестве элемента длину последовательности

        3.4.) Найдем финальный результат - минимальное число секторов,
        которое может быть на барабане с помощью функции find_res

            Рассмотрим алгоритм работы функции find_res:

            a) Функция получает на вход коллекцию элементов args.

            Эта коллекция представляет собой набор разностей между индексами чисел в исходной
            последовательности и первым индексом каждого числа, причем каждая разность встречается для любого числа.

            b) Отсотрируем ее по возрастанию и преобразуем в список

            с) Далее пройдем по всему списку разностей. Если разность
            является делителем общего числа элементов - length, то перейдем к следующему шагу,
            если нет, то продолжим обход списка, такая разность нам не подходит.
            Если ни одна из разностей не будет являтся делителем,
            то ответом будет являтся длина последовательности.

            d) Для каждой разности (lst[i]) вычислим необходимое число делимых, которое должно встретиться в последовательности
            count_of_division = (length / lst[i]) - 1.
            Например, если в последовательности из 30 чисел наименьшим числом секторов является 10,
            то получится список разностей (вместе с общим числом элементов): 10, 20, 30.
            По формуле для lst[i] = 10 найдем count_of_division = (30 / 10) - 1 = 2.
            Действительно, кроме 10 встречается только 2 делимых: 20 и 30.

            e) Далее с помощью функции find_divisors найдем это число делимых и сравним с необходимым.
            Если результат совпадает, то это и есть ответ - минимальное количество секторов.
            Прерываем цикл и возрващаем результат.
